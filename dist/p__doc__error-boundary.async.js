"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[883],{12142:function(r,e,n){n.r(e);var o=n(88811),t=n(93181),s=n(40658),l=n(1413),d=n(62410),i=n(33056),a=n(85791),c=n(29090),u=n(77797),x=n(1058),h=n(67365),y=(n(75271),n(52676)),j=s.Z.Title,p=s.Z.Paragraph,m=s.Z.Text;e.default=function(){var r=[{title:"功能特性",dataIndex:"feature",key:"feature",width:120,render:function(r){return(0,y.jsx)(m,{strong:!0,children:r})}},{title:"原生 ErrorBoundary",dataIndex:"nativeErrorBoundary",key:"nativeErrorBoundary",render:function(r,e){return(0,y.jsxs)(l.Z,{children:["nativeErrorBoundary"===e.winner&&(0,y.jsx)(o.Z,{style:{color:"#52c41a"}}),"react-error-boundary"===e.winner&&(0,y.jsx)(t.Z,{style:{color:"#ff4d4f"}}),(0,y.jsx)("span",{children:r})]})}},{title:"react-error-boundary",dataIndex:"reactErrorBoundary",key:"reactErrorBoundary",render:function(r,e){return(0,y.jsxs)(l.Z,{children:["react-error-boundary"===e.winner&&(0,y.jsx)(o.Z,{style:{color:"#52c41a"}}),"nativeErrorBoundary"===e.winner&&(0,y.jsx)(t.Z,{style:{color:"#ff4d4f"}}),(0,y.jsx)("span",{children:r})]})}}],e=[{title:"属性名",dataIndex:"prop",key:"prop",width:150,render:function(r){return(0,y.jsx)(m,{code:!0,children:r})}},{title:"类型",dataIndex:"type",key:"type",width:200,render:function(r){return(0,y.jsx)(m,{type:"secondary",children:r})}},{title:"说明",dataIndex:"description",key:"description"},{title:"必填",dataIndex:"required",key:"required",width:80,render:function(r){return(0,y.jsx)(d.Z,{color:r?"red":"green",children:r?"是":"否"})}}];return(0,y.jsxs)("div",{style:{padding:"24px"},children:[(0,y.jsxs)(j,{level:1,children:[(0,y.jsx)(t.Z,{style:{marginRight:8}}),"React Error Boundary 完整指南"]}),(0,y.jsx)(i.Z,{message:"官方推荐",description:"react-error-boundary 是 React 官方推荐的错误边界解决方案，相比自定义实现更完善且易用。",type:"info",showIcon:!0,style:{marginBottom:24}}),(0,y.jsx)(a.Z,{title:"📊 功能特性对比",style:{marginBottom:24},children:(0,y.jsx)(c.Z,{dataSource:[{key:"1",feature:"错误捕获",nativeErrorBoundary:"仅捕获子组件错误",reactErrorBoundary:"增强的错误捕获机制",winner:"react-error-boundary"},{key:"2",feature:"错误恢复",nativeErrorBoundary:"需要手动实现恢复逻辑",reactErrorBoundary:"内置 resetErrorBoundary 方法",winner:"react-error-boundary"},{key:"3",feature:"重置机制",nativeErrorBoundary:"无内置重置功能",reactErrorBoundary:"支持 resetKeys 自动重置",winner:"react-error-boundary"},{key:"4",feature:"错误上报",nativeErrorBoundary:"需要额外配置",reactErrorBoundary:"内置 onError 回调",winner:"react-error-boundary"},{key:"5",feature:"TypeScript",nativeErrorBoundary:"需要自定义类型定义",reactErrorBoundary:"完整的 TypeScript 支持",winner:"react-error-boundary"},{key:"6",feature:"开发体验",nativeErrorBoundary:"配置复杂，代码冗长",reactErrorBoundary:"API 简洁，开箱即用",winner:"react-error-boundary"}],columns:r,pagination:!1,size:"middle"})}),(0,y.jsxs)(u.Z,{gutter:[16,16],style:{marginBottom:24},children:[(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsxs)(a.Z,{title:"📦 安装",style:{height:"100%"},children:[(0,y.jsx)(j,{level:4,children:"NPM"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"npm install react-error-boundary"})}),(0,y.jsx)(j,{level:4,children:"Yarn"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"yarn add react-error-boundary"})}),(0,y.jsx)(j,{level:4,children:"PNPM"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"pnpm add react-error-boundary"})})]})}),(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsxs)(a.Z,{title:"🚀 基础用法",style:{height:"100%"},children:[(0,y.jsx)(j,{level:4,children:"基本封装"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"import ErrorBoundary from react-error-boundary;"})}),(0,y.jsx)(j,{level:4,children:"核心特性"}),(0,y.jsxs)("ul",{children:[(0,y.jsx)("li",{children:"增强的错误捕获机制"}),(0,y.jsx)("li",{children:"内置错误恢复功能"}),(0,y.jsx)("li",{children:"支持自动重置"}),(0,y.jsx)("li",{children:"完整的 TypeScript 支持"}),(0,y.jsx)("li",{children:"简洁的 API 设计"})]})]})})]}),(0,y.jsx)(a.Z,{title:"⚙️ 核心 Props 详解",style:{marginBottom:24},children:(0,y.jsx)(c.Z,{dataSource:[{prop:"FallbackComponent",type:"React.ComponentType<FallbackProps>",description:"错误时显示的组件",required:!1},{prop:"fallbackRender",type:"(props: FallbackProps) => ReactNode",description:"替代组件的渲染函数",required:!1},{prop:"onError",type:"(error: Error, info: { componentStack: string }) => void",description:"错误捕获回调函数",required:!1},{prop:"onReset",type:"() => void",description:"重置时触发的回调",required:!1},{prop:"resetKeys",type:"Array<any>",description:"变化时会触发重置的依赖数组",required:!1}],columns:e,pagination:!1,size:"middle"})}),(0,y.jsxs)(u.Z,{gutter:[16,16],style:{marginBottom:24},children:[(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsxs)(a.Z,{title:"🎯 基础实现",style:{height:"100%"},children:[(0,y.jsx)(j,{level:4,children:"错误回退组件"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:'function ErrorFallback({ error, resetErrorBoundary }: {\n  error: Error;\n  resetErrorBoundary: () => void;\n}) {\n  return (\n    <div role="alert">\n      <h3>出错了</h3>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>重试</button>\n    </div>\n  );\n}'})}),(0,y.jsx)(j,{level:4,children:"基本使用"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"function App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => window.location.reload()}\n    >\n      <YourComponent />\n    </ErrorBoundary>\n  );\n}"})})]})}),(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsxs)(a.Z,{title:"🔄 错误恢复机制",style:{height:"100%"},children:[(0,y.jsx)(j,{level:4,children:"局部恢复"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"function Example() {\n  const [shouldFail, setShouldFail] = useState(false);\n  \n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => setShouldFail(false)}\n      resetKeys={[shouldFail]}\n    >\n      {shouldFail ? <BuggyComponent /> : \n       <button onClick={() => setShouldFail(true)}>触发错误</button>}\n    </ErrorBoundary>\n  );\n}"})}),(0,y.jsx)(j,{level:4,children:"自动重置"}),(0,y.jsxs)(p,{children:["通过 ",(0,y.jsx)(m,{code:!0,children:"resetKeys"})," 实现依赖变化时的自动重置，无需手动调用重置函数。"]})]})})]}),(0,y.jsx)(h.Z,{}),(0,y.jsx)(a.Z,{title:"🔧 UmiMax 集成方案",style:{marginBottom:24},children:(0,y.jsxs)(u.Z,{gutter:[24,16],children:[(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"全局错误边界"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"// app.tsx\nexport function rootContainer(container: React.ReactNode) {\n  return (\n    <ErrorBoundary FallbackComponent={GlobalErrorFallback}>\n      {container}\n    </ErrorBoundary>\n  );\n}"})})]}),(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"路由级错误边界"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"// config/routes.ts\nexport default [\n  {\n    path: '/user',\n    component: '@/pages/User',\n    errorBoundary: '@/components/UserErrorBoundary'\n  }\n]"})})]}),(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"API 请求错误处理"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"import { useErrorBoundary } from 'react-error-boundary';\n\nfunction UserProfile() {\n  const { showBoundary } = useErrorBoundary();\n\n  const fetchData = async () => {\n    try {\n      await fetch('/api/user');\n    } catch (err) {\n      showBoundary(err);\n    }\n  };\n}"})})]})]})}),(0,y.jsxs)(a.Z,{title:"🚀 高级用法",style:{marginBottom:24},children:[(0,y.jsxs)(u.Z,{gutter:[16,16],children:[(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsx)(a.Z,{title:"🔗 嵌套边界",size:"small",children:(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"<ErrorBoundary FallbackComponent={ParentFallback}>\n  <ComponentA />\n  <ErrorBoundary FallbackComponent={ChildFallback}>\n    <ComponentB />\n  </ErrorBoundary>\n</ErrorBoundary>"})})})}),(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsx)(a.Z,{title:"📊 错误上报集成",size:"small",children:(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"<ErrorBoundary\n  onError={(error, info) => {\n    Sentry.captureException(error, { extra: { info } });\n    fetch('/log-error', { \n      method: 'POST',\n      body: JSON.stringify({ error: error.stack, componentStack: info.componentStack })\n    });\n  }}\n>\n  <App />\n</ErrorBoundary>"})})})})]}),(0,y.jsxs)(u.Z,{gutter:[16,16],style:{marginTop:16},children:[(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsx)(a.Z,{title:"🔄 重置依赖示例",size:"small",children:(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"function ProductPage({ productId }: { productId: string }) {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      resetKeys={[productId]}\n    >\n      <ProductDetails productId={productId} />\n    </ErrorBoundary>\n  );\n}"})})})}),(0,y.jsx)(x.Z,{xs:24,lg:12,children:(0,y.jsx)(a.Z,{title:"🎣 异步错误捕获 Hook",size:"small",children:(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"export function useAsyncTask() {\n  const { showBoundary } = useErrorBoundary();\n\n  const runSafe = async <T,>(task: Promise<T>): Promise<T | undefined> => {\n    try {\n      return await task;\n    } catch (error) {\n      showBoundary(error);\n    }\n  };\n\n  return { runSafe };\n}"})})})})]})]}),(0,y.jsx)(a.Z,{title:"🛠️ 实用工具函数",style:{marginBottom:24},children:(0,y.jsxs)(u.Z,{gutter:[16,16],children:[(0,y.jsxs)(x.Z,{xs:24,lg:12,children:[(0,y.jsx)(j,{level:4,children:"通用错误回退组件"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:'export function ErrorFallback({\n  error,\n  resetErrorBoundary,\n  customMessage\n}: {\n  error: Error;\n  resetErrorBoundary: () => void;\n  customMessage?: string;\n}) {\n  return (\n    <div className="error-fallback">\n      <Alert type="error" \n        message={customMessage || \'发生错误\'} \n        description={<pre>{error.message}</pre>}\n      />\n      <Space>\n        <Button onClick={resetErrorBoundary}>重试</Button>\n        <Button onClick={() => window.location.reload()}>刷新页面</Button>\n      </Space>\n    </div>\n  );\n}'})})]}),(0,y.jsxs)(x.Z,{xs:24,lg:12,children:[(0,y.jsx)(j,{level:4,children:"TypeScript 类型定义"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"interface FallbackProps {\n  error: Error;\n  resetErrorBoundary: (...args: Array<unknown>) => void;\n}\n\ninterface ErrorBoundaryProps {\n  FallbackComponent?: React.ComponentType<FallbackProps>;\n  fallbackRender?: (props: FallbackProps) => ReactNode;\n  onError?: (error: Error, info: { componentStack: string }) => void;\n  onReset?: () => void;\n  resetKeys?: Array<any>;\n}"})})]})]})}),(0,y.jsxs)(a.Z,{title:"💡 最佳实践建议",children:[(0,y.jsxs)(u.Z,{gutter:[16,16],children:[(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"分层处理"}),(0,y.jsxs)("ul",{children:[(0,y.jsx)("li",{children:"全局边界处理意外崩溃"}),(0,y.jsx)("li",{children:"路由边界处理页面级错误"}),(0,y.jsx)("li",{children:"组件边界处理关键UI部分"})]})]}),(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"错误恢复"}),(0,y.jsxs)("ul",{children:[(0,y.jsx)("li",{children:"简单场景：resetErrorBoundary 局部恢复"}),(0,y.jsx)("li",{children:"复杂状态：通过 resetKeys 自动重置"}),(0,y.jsx)("li",{children:"彻底失败：引导用户刷新页面"})]})]}),(0,y.jsxs)(x.Z,{xs:24,md:8,children:[(0,y.jsx)(j,{level:4,children:"开发体验"}),(0,y.jsxs)("ul",{children:[(0,y.jsx)("li",{children:"开发环境显示详细错误"}),(0,y.jsx)("li",{children:"生产环境提供用户友好的错误信息"}),(0,y.jsx)("li",{children:"集成错误监控和上报"})]})]})]}),(0,y.jsx)(h.Z,{}),(0,y.jsx)(j,{level:4,children:"环境适配示例"}),(0,y.jsx)(p,{children:(0,y.jsx)(m,{code:!0,children:"<ErrorBoundary\n  FallbackComponent={process.env.NODE_ENV === 'development' ? \n    DevErrorFallback : ProdErrorFallback}\n>\n  <App />\n</ErrorBoundary>"})}),(0,y.jsx)(i.Z,{message:"总结",description:"通过合理配置，react-error-boundary 可以覆盖 90% 以上的 React 错误处理场景，比原生 ErrorBoundary 更灵活强大。建议在项目中统一使用此库来处理错误边界。",type:"success",showIcon:!0,style:{marginTop:16}})]})]})}}}]);